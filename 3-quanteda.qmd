---
title: Quantitative analysis of textual data
editor_options: 
  chunk_output_type: console
---

- https://tutorials.quanteda.io/introduction/


## Introduction

There are several R packages used for quantitative text analysis, but we will focus specifically on the `{quanteda}` package. So, first install the package from CRAN:

```{r}
#| eval: false
install.packages("quanteda")
```

Since the release of `{quanteda}` version 3.0, `textstat_*`, `textmodel_*` and `textplot_*` functions are available in separate packages. We will use several of these functions in the chapters below and strongly recommend installing these packages.


```{r}
#| eval: false
install.packages("quanteda.textmodels")
install.packages("quanteda.textstats")
install.packages("quanteda.textplots")
```

We will use the `{readtext}` package to read in different types of text data in these tutorials. 


```{r}
#| eval: false
install.packages("readtext")
```


## Quantitative data 

Before beginning we need to load the libraries

```{r}
#| message: false
library(tidyverse)
library(quanteda)
library(readtext)
```

### Pre-formatted files

If your text data is stored in a pre-formatted file where one column contains the text and additional columns might store document-level variables (e.g. year, author, or language), you can import this into R using `read_csv()`.

```{r}
path_data <- system.file("extdata/", package = "readtext")
dat_inaug <- read_csv(paste0(path_data, "/csv/inaugCorpus.csv"))
glimpse(dat_inaug)
```

The data set is about the inaugural speeches of the US presidents. So as we can see the data set is arranged in tabular form, with 5 rows and 4 columns. The columns are `texts`, `Year`, `President`, and `FirstName`. 

Alternatively, you can use the `{readtext}` package to import character (comma- or tab-separated) values. `{readtext}` reads files containing text, along with any associated document-level variables. As an example, consider the following tsv file:

```{r}
tsv_file <- paste0(path_data, "/tsv/dailsample.tsv")
cat(readLines(tsv_file, n = 4), sep = "\n")  # first 3 lines
```

The document itself in raw format is arranged in tabular form, separated by tabs. Each row contains a "document" (in this case, a speech) and the columns contain **document-level** variables. The column that contains the actual speech is named `speech`. To import this using `{readtext}`, you can use the following code:

```{r}
dat_dail <- readtext(tsv_file, text_field = "speech")
glimpse(dat_dail)
```

### Multiple text files

A second option to import data is to load multiple text files at once that are stored in the same folder or subfolders. Again, `path_data` is the location of sample files on your computer. Unlike the pre-formatted files, individual text files usually do not contain document-level variables. However, you can create document-level variables using the `{readtext}` package.

The directory `/txt/UDHR` contains text files (".txt") of the Universal Declaration of Human Rights in 13 languages. 

```{r}
path_udhr <- paste0(path_data, "/txt/UDHR")
list.files(path_udhr)  # list the files in this folder
```

Each one of these txt files contains the text of the UDHR in the specific language.
For instance, to inspect what each one of these files contain, we do the following:

```{r}
# just first 5 lines
cat(readLines(file.path(path_udhr, "UDHR_chinese.txt"), n = 5), sep = "\n")  
```

To import these files, you can use the following code:

```{r}
dat_udhr <- readtext(path_udhr)
glimpse(dat_udhr)
```

::: {.callout-note}
If you are using Windows, you need might need to specify the encoding of the file by adding `encoding = "utf-8"`. In this case, imported texts might appear like `<U+4E16><U+754C><U+4EBA><U+6743>` but they indicate that Unicode charactes are imported correctly.
:::

Here's another example of multiple text files. The directory `/txt/EU_manifestos` contains text files (".txt") of the European Union manifestos in different languages. 

```{r}
path_eu <- paste0(path_data, "/txt/EU_manifestos/")
list.files(path_eu)  # list the files in this folder
```

You can generate document-level variables based on the file names using the `docvarnames` and `docvarsfrom` argument. `dvsep = "_"` specifies the value separator in the filenames. `encoding = "ISO-8859-1"` determines character encodings of the texts. Notice how the document variables are nicely generated from the file names.

```{r}
dat_eu <- readtext(
  file = path_eu,
  docvarsfrom = "filenames", 
  docvarnames = c("unit", "context", "year", "language", "party"),
  dvsep = "_", 
  encoding = "ISO-8859-1"
)
glimpse(dat_eu)
```

### JSON

You can also read JSON files (.json) downloaded from the Twititer stream API. [twitter.json](https://raw.githubusercontent.com/quanteda/tutorials.quanteda.io/master/content/data/twitter.json) is located in data directory of this tutorial package.

The JSON file looks something like this

```
{"created_at":"Wed Jun 07 23:30:01 +0000 2017","id":872596537142116352,"id_str":"872596537142116352","text":"@EFC_Jayy UKIP","display_text_range":[10,14],
"source":"\u003ca href=\"http:\/\/twitter.com\/download\/iphone\" rel=\"nofollow\"\u003eTwitter for iPhone\u003c\/a\u003e","truncated":false,"in_reply_to_status_id":872596176834572288,
"in_reply_to_status_id_str":"872596176834572288","in_reply_to_user_id":4556760676,"in_reply_to_user_id_str":"4556760676","in_reply_to_screen_name":"EFC_Jayy","user":{"id":863929468984995840,"id_str":"863929468984995840","name":"\u30b8\u30e7\u30fc\u30b8","screen_name":"CoysJoji","location":"Japan","url":null,"description":null,"protected":false,
"verified":false,"followers_count":367,"friends_count":304,"listed_count":1,"favourites_count":1260,"statuses_count":2930,"created_at":"Mon May 15 01:30:11 +0000 2017","utc_offset":null,"time_zone":null,"geo_enabled":false,"lang":"en","contributors_enabled":false,"is_translator":false,"profile_background_color":"F5F8FA","profile_background_image_url":"","profile_background_image_url_https":"","profile_background_tile":false,
"profile_link_color":"1DA1F2","profile_sidebar_border_color":"C0DEED","profile_sidebar_fill_color":"DDEEF6","profile_text_color":"333333","profile_use_background_image":true,"profile_image_url":"http:\/\/pbs.twimg.com\/profile_images\/870447188400365568\/RiR1hbCe_normal.jpg",
"profile_image_url_https":"https:\/\/pbs.twimg.com\/profile_images\/870447188400365568\/RiR1hbCe_normal.jpg","profile_banner_url":"https:\/\/pbs.twimg.com\/profile_banners\/863929468984995840\/1494897624","default_profile":true,"default_profile_image":false,"following":null,"follow_request_sent":null,"notifications":null},"geo":null,"coordinates":null,
"place":null,"contributors":null,"is_quote_status":false,"retweet_count":0,"favorite_count":0,"entities":{"hashtags":[],"urls":[],"user_mentions":[{"screen_name":"EFC_Jayy","name":"\u274c\u274c\u274c","id":4556760676,"id_str":"4556760676","indices":[0,9]}],"symbols":[]},"favorited":false,"retweeted":false,"filter_level":"low","lang":"en","timestamp_ms":"1496878201171"}
```

It's a little hard to parse, but luckily we just leave it to the `{readtext}` package to do the job for us.

```{r}
#| eval: false
dat_twitter <- readtext("../data/twitter.json", source = "twitter")
```

The file comes with several metadata for each tweet, such as the number of retweets and likes, the username, time and time zone. 


```{r}
#| eval: false
head(names(dat_twitter))
```

```
## [1] "doc_id"         "text"           "retweet_count"  "favorite_count"
## [5] "favorited"      "truncated"
```

### PDF

`readtext()` can also convert and read PDF (".pdf") files. The directory `/pdf/UDHR` contains PDF files of the Universal Declaration of Human Rights in 13 languages. Each file looks like this:

![](figures/udhr_sample.png)


```{r}
dat_udhr <- readtext(
  paste0(path_data, "/pdf/UDHR/*.pdf"), 
  docvarsfrom = "filenames", 
  docvarnames = c("document", "language"),
  sep = "_"
)
print(dat_udhr)
```

### Microsoft Word

Finally, `readtext()` can import Microsoft Word (".doc" and ".docx") files.

```{r}
dat_word <- readtext(paste0(path_data, "/word/*.docx"))
print(dat_udhr)
```

## Workflow

`{quanteda}` has three basic types of objects:

1.  Corpus
    
    * Saves character strings and variables in a data frame
    * Combines texts with document-level variables

2.  Tokens
    
    * Stores tokens in a list of vectors
    * More efficient than character strings, but preserves positions of words 
    * Positional (string-of-words) analysis is performed using `textstat_collocations()`, `tokens_ngrams()` and `tokens_select()` or `fcm()` with `window` option

3.  Document-feature matrix (DFM)

    * Represents frequencies of features in documents in a matrix
    * The most efficient structure, but it does not have information on positions of words 
    * Non-positional (bag-of-words) analysis are profrmed using many of the `textstat_*` and `textmodel_*` functions 

Text analysis with `{quanteda}` goes through all those three types of objects either explicitly or implicitly.

```{mermaid}
    graph TD
    D[Text files]
    V[Document-level variables]
    C(Corpus)
    T(Tokens)
    AP["Positional analysis (string-of-words)"]
    AN["Non-positional analysis (bag-of-words)"]
    M(DFM)
    style C stroke-width:4px
    style T stroke-width:4px
    style M stroke-width:4px
    D --> C
    V --> C 
    C --> T 
    T --> M
    T -.-> AP
    M -.-> AN
```

For example, if character vectors are given to `dfm()`, it internally constructs corpus and tokens objects before creating a DFM. 

### Corpus

You can create a corpus from various available sources:

1. A character vector consisting of one document per element

2. A data frame consisting of a character vector for documents, and additional vectors for document-level variables



#### Character vector

`data_char_ukimmig2010` is a named character vector and consists of sections of British election manifestos on immigration and asylum.


```{r}
str(data_char_ukimmig2010)
corp_immig <- corpus(
  data_char_ukimmig2010, 
  docvars = data.frame(party = names(data_char_ukimmig2010))
)
print(corp_immig)
summary(corp_immig)
```

#### Data frame

Using `read_csv()`, load an example file from `path_data` as a data frame called `dat_inaug`. Note that your file does not need to be formatted as `.csv`. You can build a `{quanteda}` corpus from any file format that R can import as a data frame (see, for instance, the [**rio**](https://cran.r-project.org/web/packages/rio/index.html) package for importing various files as data frames into R).


```{r}
# set path
path_data <- system.file("extdata/", package = "readtext")

# import csv file
dat_inaug <- read.csv(paste0(path_data, "/csv/inaugCorpus.csv"))
names(dat_inaug)
```

Construct a corpus from the "texts" column in `dat_inaug`.


```{r}
corp_inaug <- corpus(dat_inaug, text_field = "texts")
print(corp_inaug)
```

#### Document-level variables

`{quanteda}`'s objects keep information associated with documents. They are called "document-level variables", or "docvars", and are accessed using `docvars()`.


```{r}
corp <- data_corpus_inaugural
head(docvars(corp))
```

If you want to extract individual elements of document variables, you can specify `field`. Or you could just subset it as you normally would a data.frame.

```{r}
docvars(corp, field = "Year")
corp$Year
```

So that means assignments to *change* document-level variables will work as usual in R. For example, you can change the `Year` variable to a factor (if you wished). And since the output of a `docvars()` function is a data.frame, you could subset or filter as you would a data.frame.

```{r}
docvars(corp) |>
  filter(Year >= 1990)
# {quanteda} also provides corpus_subset() function, but since we learnt about
# dplyr, we can use it here.
```



### Tokens

### Document feature matrix
