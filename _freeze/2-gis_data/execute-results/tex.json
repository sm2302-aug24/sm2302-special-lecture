{
  "hash": "972a7b5c331da9c633d753e79035a1f2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Geographical Information System (GIS) data\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n\n\nLibraries needed:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n# remotes::install_github(\"propertypricebn/bruneimap\")\nlibrary(bruneimap)\nlibrary(ggrepel)\nlibrary(kernlab)\nlibrary(osrm)\nlibrary(osmdata)\n```\n:::\n\n\n\n\n\n\nMore info: \n\n- [https://github.com/propertypricebn/bruneimap](https://github.com/propertypricebn/bruneimap)\n\n::: {.callout-note}\nThe `{bruneimap}` package contains the following data sets:\n\n1. `dis_sf`: Brunei districts geometries.\n2. `mukim_sf`: Brunei mukim geometries.\n3. `kpg_sf`: Brunei kampong geometries.\n5. `brn_df`: Brunei outline geometries.\n4. `bn_census2021`: Brunei 2021 census data.\n:::\n\n## Introduction\n\n::: {.callout-tip title=\"What we'll learn\"}\n-   Types of GIS data and how these are handled in R.\n-   Difference between spatial and non-spatial data analysis.\n-   Importance of geocoding your data for spatial analysis.\n:::\n\nRoughly speaking, there are 4 types of GIS data.\n\n1.  **Points**\n    -   Having $(X, Y)$ coordinates (latitude, longitude, or projected coordinates, and are \"zero-dimensional\".\n    -   E.g. shopping malls, hospitals, outbreaks, etc.\n2.  **Lines**\n    -   A collection of points that form a path or a boundary. Has length.\n    -   E.g. roads, rivers, pipelines, etc.\n3.  **Polygons**\n    -   A closed area made up of line segments or curves.\n    -   E.g. countries, districts, buildings, etc.\n4.  **Raster**\n    -   Pixelated (or gridded) data where each pixel is associated with a geographical area and some measurement.\n    -   E.g. satellite images, elevation data, etc.\n\nThe first three are usually referred to as *vector data*. GIS data can be stored in various formats such as `.shp` or `.geojson`. The handling of GIS data (at least vector type data) is facilitated by the `{sf}` package [@pebesma2023spatial] which uses the *simple features* standard.\n\n::: callout-note\n*Simple features* refers to a formal standard (ISO 19125-1:2004) that describes how objects in the real world can be represented in computers, with emphasis on the spatial geometry of these objects.\n:::\n\nIt's helpful to think about the shape of this spatial data set. As an example, here's a random slice of 10 kampong-level population data for Brunei:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(\n  kpg_sf, \n  bn_census2021, \n  join_by(id, kampong, mukim, district)\n) |>\n  select(\n    kampong, district, population, geometry\n  ) |>\n  slice_sample(n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 10 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 114.437 ymin: 4.395845 xmax: 115.2607 ymax: 4.996198\nGeodetic CRS:  WGS 84\n# A tibble: 10 x 4\n   kampong                    district     population                   geometry\n   <chr>                      <chr>             <dbl>              <POLYGON [°]>\n 1 Kg. Batong                 Brunei Muara       1319 ((114.8262 4.842174, 114.~\n 2 Kg. Batang Perhentian      Brunei Muara        346 ((114.8143 4.769514, 114.~\n 3 Kg. Simbatang Bokok        Temburong            58 ((115.0804 4.633709, 115.~\n 4 Kg. Semabat                Temburong            95 ((115.1047 4.578915, 115.~\n 5 Kg. Sungai Orok            Brunei Muara       1071 ((114.9828 4.980276, 114.~\n 6 Kawasan Bahaya Mukim Bokok Temburong            NA ((115.1105 4.527953, 115.~\n 7 Pulau ...                  Brunei Muara         NA ((115.0419 4.995619, 115.~\n 8 Kg. Labi Lama              Belait                4 ((114.4552 4.407087, 114.~\n 9 Kg. Senukoh                Temburong           250 ((115.2302 4.766017, 115.~\n10 Kg. Bengkurong             Brunei Muara       3357 ((114.8602 4.858023, 114.~\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSpatial data analysis must have these two components:\n\n1.  The study variables (in the above example, this is population data).\n2.  GIS data regarding that study variable.\n\nIf we only have 1 without 2, then it really is just a regular data analysis (stating the obvious). Adding the GIS data is a process called \"geocoding\" the data points.\n\n::: callout-note\nIn R, geocoding using `{tidyverse}` can be achieved using the `dplyr::left_join()` or similar `xxx_join()` family of functions.\n:::\n\n## `(MULTI)POINT` data\n\n::: {.callout-tip title=\"What we'll learn\"}\n-   Loading data sets in R using `readr::read_csv()`.\n-   Identifying data types and their implications.\n:::\n\nUse the data from @jaafar2023data on the physicochemical characteristics and texture classification of soil in Bornean tropical heath forests affected by exotic Acacia mangium. There are three datasets provided.\n\n1.  GIS data ([WGS84](https://en.wikipedia.org/wiki/World_Geodetic_System \"World Geodetic System\") coordinates) of all study plots.\n2.  Soil physicochemical property data. This contains details of soil physical, chemical, nutrient concentration of the three habits studied.\n3.  Soil texture classification. Provides details on the classification of the soil texture in the habitats studied.\n\nWe will first load the data sets in R.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the data sets\nsoil_gps <- read_csv(\n  \"data/8389823/GPS - Revised.csv\", \n  # IMPORTANT!!! The csv file has latin1 encoding as opposed to UTF-8\n  locale = readr::locale(encoding = \"latin1\")\n)\n  \nsoil_physico <- read_csv(\"data/8389823/Soil physicochemical properties.csv\")\nsoil_texture <- read_csv(\"data/8389823/Soil texture classification.csv\")\n```\n:::\n\n\n\n\n\n\n### Clean up the point data\n\n::: {.callout-tip title=\"What we'll learn\"}\n-   Highlighting the need for cleaning and preprocessing data.\n-   Using `glimpse()` to peek at the data.\n-   Using `mutate()` to change stuff in the data set.\n-   Using `str()` to look at the structure of an R object.\n:::\n\nLet's take a look at the point data set.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nglimpse(soil_gps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 18\nColumns: 5\n$ Forest_type  <chr> \"Kerangas\", \"Kerangas\", \"Kerangas\", \"Kerangas\", \"Kerangas~\n$ Habitat_type <chr> \"Intact\", \"Intact\", \"Intact\", \"Intact\", \"Intact\", \"Intact~\n$ Plot_name    <chr> \"KU1\", \"KU2\", \"KU3\", \"KU4\", \"KU5\", \"KU6\", \"KI1\", \"KI2\", \"~\n$ Latitude     <chr> \"4° 35' 53.40\\\"N\", \"4° 35' 38.37\\\"N\", \"4° 35' 53.89\\\"N\", ~\n$ Longitude    <chr> \"114° 30' 39.09\\\"E\", \"114° 31' 05.89\\\"E\", \"114° 30' 38.90~\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe first three columns are essentially the identifiers of the plots (forest type, habitat type, and the unique identification code for the study plot). However, the latitude and longitude needs a bit of cleaning up, because it's currently in character format. This needs to be in a formal Degree Minute Second `DMS` class that R can understand. For this we will use the `sp::char2dms()` function.\n\nAs an example let's take a look at the first latitude.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- soil_gps$Latitude[1]\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"4° 35' 53.40\\\"N\"\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# convert it using sp::char2dms() function\nx <- sp::char2dms(x, chd = \"°\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4d35'53.4\"N\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFormal class 'DMS' [package \"sp\"] with 5 slots\n  ..@ WS : logi FALSE\n  ..@ deg: int 4\n  ..@ min: int 35\n  ..@ sec: num 53.4\n  ..@ NS : logi TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis is a special class that R understands as being a latitude from Earth. To convert it to decimal, we just do `as.numeric()`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.598167\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow let's do this for all the values in the `soil_gps` data. We will use the `dplyr::mutate()` function in a pipeline.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoil_gps <-\n  soil_gps |>\n  mutate(\n    Latitude = as.numeric(sp::char2dms(Latitude, chd = \"°\")),\n    Longitude = as.numeric(sp::char2dms(Longitude, chd = \"°\"))\n  )\nsoil_gps\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 x 5\n   Forest_type Habitat_type Plot_name Latitude Longitude\n   <chr>       <chr>        <chr>        <dbl>     <dbl>\n 1 Kerangas    Intact       KU1           4.60      115.\n 2 Kerangas    Intact       KU2           4.59      115.\n 3 Kerangas    Intact       KU3           4.60      115.\n 4 Kerangas    Intact       KU4           4.63      114.\n 5 Kerangas    Intact       KU5           4.60      115.\n 6 Kerangas    Intact       KU6           4.60      115.\n 7 Kerangas    Invaded      KI1           4.59      115.\n 8 Kerangas    Invaded      KI2           4.59      115.\n 9 Kerangas    Invaded      KI3           4.59      115.\n10 Kerangas    Invaded      KI4           4.59      115.\n11 Kerangas    Invaded      KI5           4.59      115.\n12 Kerangas    Invaded      KI6           4.59      115.\n13 Kerangas    Plantation   AP1           4.59      115.\n14 Kerangas    Plantation   AP2           4.59      115.\n15 Kerangas    Plantation   AP3           4.59      115.\n16 Kerangas    Plantation   AP4           4.59      115.\n17 Kerangas    Plantation   AP5           4.59      115.\n18 Kerangas    Plantation   AP6           4.59      115.\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Preliminary plot of the data\n\n::: {.callout-tip title=\"What we'll learn\"}\n-   Structure of a `ggplot()` (grammar of graphics).\n-   Using `geom_sf()` to plot the GIS data, and adding points using `geom_point()`.\n:::\n\nUsing the data contained in the `{bruneimap}` package, we can plot the study areas on a map of Brunei. Use either the `brn_sf`, `dis_sf`, `mkm_sf` or `kpg_sf` data sets.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(brn_sf) +\n  geom_sf() +\n  geom_point(data = soil_gps, aes(Longitude, Latitude)) \n```\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\nWe can zoom in a bit... but we have to find out manually the correct bounding box.\nTo do this, we can either:\n\n1. Manually find the minimum and maximum values of the latitude and longitude.\n2. Convert the `soil_gps` data set to an `sf` object and use the `st_bbox()` function.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Manual way\nc(\n  xmin = min(soil_gps$Longitude), xmax = max(soil_gps$Longitude),\n  ymin = min(soil_gps$Latitude), ymax = max(soil_gps$Latitude)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      xmin       xmax       ymin       ymax \n114.473356 114.529297   4.592817   4.630242 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Using the sf object\nsoil_sf <- st_as_sf(soil_gps, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)\nst_bbox(soil_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      xmin       ymin       xmax       ymax \n114.473356   4.592817 114.529297   4.630242 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow that we've found the bound box, we can plot better:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mkm_sf) +\n  geom_sf() +\n  geom_sf(data = dis_sf, fill = NA, col = \"black\", linewidth = 1) +\n  geom_point(data = soil_gps, aes(Longitude, Latitude)) +\n  geom_text_repel(\n    data = soil_gps,\n    aes(Longitude, Latitude, label = Plot_name),\n    box.padding = 0.5,\n    max.overlaps = 30\n  ) +\n  coord_sf(\n    xlim = c(114.4, 114.6),\n    ylim = c(4.5, 4.7)\n  )\n```\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-10-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n### Merge with the study data\n\n::: {.callout-tip title=\"What we'll learn\"}\n-   Using `left_join()` to merge two data sets together.\n-   Using `geom_jitter()` to plot the study variables that are overlapping.\n:::\n\nLet's take a look at the data set.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nglimpse(soil_physico)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 144\nColumns: 16\n$ Habitat_type              <chr> \"Intact\", \"Intact\", \"Intact\", \"Intact\", \"Int~\n$ Plot_name                 <chr> \"KU1\", \"KU1\", \"KU1\", \"KU1\", \"KU1\", \"KU1\", \"K~\n$ Subplot_name              <chr> \"A\", \"A\", \"B\", \"B\", \"C\", \"C\", \"D\", \"D\", \"A\",~\n$ Soil_depth                <chr> \"0-15\", \"30-50\", \"0-15\", \"30-50\", \"0-15\", \"3~\n$ Nitrogen                  <dbl> 0.617, 0.188, 0.663, 0.200, 0.465, 0.255, 0.~\n$ Phosphorus                <dbl> 0.248, 0.129, 0.259, 0.295, 0.172, 0.145, 0.~\n$ Magnesium                 <dbl> 0.000, 0.045, 0.054, 0.035, 0.079, 0.043, 0.~\n$ Calcium                   <dbl> 0.167, 0.187, 0.148, 0.113, 0.253, 0.229, 0.~\n$ Potassium                 <dbl> 0.059, 0.037, 0.054, 0.022, 0.098, 0.033, 0.~\n$ Exchangable_magnesium     <dbl> 0.009, 0.004, 0.007, 0.005, 0.029, 0.014, 0.~\n$ Exchangable_calcium       <dbl> 0.010, 0.009, 0.008, 0.009, 0.109, 0.041, 0.~\n$ Exchangable_potassium     <dbl> 0.101, 0.085, 0.092, 0.087, 0.101, 0.090, 0.~\n$ Available_phosphorus      <dbl> 0.012, 0.012, 0.013, 0.012, 0.013, 0.014, 0.~\n$ pH                        <dbl> 2.3, 2.7, 2.0, 2.0, 2.6, 2.5, 2.3, 2.1, 1.0,~\n$ Gravimetric_water_content <dbl> 5.911, 3.560, 10.860, 5.082, 6.963, 4.549, 5~\n$ Organic_matter            <dbl> 4.559, 1.399, 4.523, 2.309, 3.131, 2.209, 3.~\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nglimpse(soil_texture)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 144\nColumns: 8\n$ Habitat_type           <chr> \"Intact\", \"Intact\", \"Intact\", \"Intact\", \"Intact~\n$ Plot_name              <chr> \"KU1\", \"KU1\", \"KU1\", \"KU1\", \"KU2\", \"KU2\", \"KU2\"~\n$ Subplot_name           <chr> \"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\", \"D\", \"A\", \"B~\n$ Soil_depth             <chr> \"0-15\", \"0-15\", \"0-15\", \"0-15\", \"0-15\", \"0-15\",~\n$ Clay                   <dbl> 0.0, 0.0, 0.0, 0.0, 0.0, 2.5, 2.5, 2.5, 0.0, 2.~\n$ Silt                   <dbl> 2.5, 0.0, 0.0, 2.5, 0.0, 0.0, 2.5, 2.5, 7.5, 7.~\n$ Sand                   <dbl> 97.5, 100.0, 100.0, 97.5, 100.0, 97.5, 95.0, 95~\n$ Texture_classification <chr> \"Sand\", \"Sand\", \"Sand\", \"Sand\", \"Sand\", \"Sand\",~\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `soil_physico` and `soil_texture` data sets contain the same columns, so we might as well merge them together. We will use the `dplyr::left_join()` function.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Actually I just want to merge these two together\nsoil_df <- left_join(\n  soil_physico,\n  soil_texture,\n  by = join_by(Habitat_type, Plot_name, Subplot_name, Soil_depth)\n)\nsoil_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 144 x 20\n   Habitat_type Plot_name Subplot_name Soil_depth Nitrogen Phosphorus Magnesium\n   <chr>        <chr>     <chr>        <chr>         <dbl>      <dbl>     <dbl>\n 1 Intact       KU1       A            0-15          0.617      0.248     0    \n 2 Intact       KU1       A            30-50         0.188      0.129     0.045\n 3 Intact       KU1       B            0-15          0.663      0.259     0.054\n 4 Intact       KU1       B            30-50         0.2        0.295     0.035\n 5 Intact       KU1       C            0-15          0.465      0.172     0.079\n 6 Intact       KU1       C            30-50         0.255      0.145     0.043\n 7 Intact       KU1       D            0-15          0.285      0.225     0.052\n 8 Intact       KU1       D            30-50         0.057      0.207     0.031\n 9 Intact       KU2       A            0-15          0.37       0.135     0.038\n10 Intact       KU2       A            30-50         0.114      0.168     0.021\n# i 134 more rows\n# i 13 more variables: Calcium <dbl>, Potassium <dbl>,\n#   Exchangable_magnesium <dbl>, Exchangable_calcium <dbl>,\n#   Exchangable_potassium <dbl>, Available_phosphorus <dbl>, pH <dbl>,\n#   Gravimetric_water_content <dbl>, Organic_matter <dbl>, Clay <dbl>,\n#   Silt <dbl>, Sand <dbl>, Texture_classification <chr>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nOnce we've done that, the `soil_df` data set (the study variables) is actually missing the spatial data. We need to geocode it with the `soil_gps` data set. Again, `dplyr::left_join()` to the rescue!\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoil_df <- left_join(\n  soil_df, \n  soil_gps,\n  by = join_by(Habitat_type, Plot_name)\n)\n```\n:::\n\n\n\n\n\n\nNow we're in a position to plot the study variables on the map. Note that there are only 18 plots in the `soil_gps` data set, and each plot has repeated measurements. That means when we plot it, it will overlap and look like a single point. So a good thing to do is to jitter the point so it's easier to see.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(kpg_sf) +\n  geom_sf(fill = NA) +\n  geom_jitter(\n    data = soil_df, \n    aes(Longitude, Latitude, col = Nitrogen, size = Nitrogen, \n        shape = Habitat_type),\n    width = 0.001, height = 0.001, alpha = 0.7\n  ) +\n  coord_sf(\n    xlim = c(114.46, 114.54),\n    ylim = c(4.58, 4.64)\n  ) +\n  scale_color_viridis_c() +\n  guides(size = \"none\")\n```\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-14-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n## Line data (`(MULTI)LINESTRING`)\n\n::: {.callout-tip title=\"What we'll learn\"}\n-   How to load spatial data sets using `sf::read_sf()` and editing the CRS using `sf::st_transform()`.\n-   How to filter data using `dplyr::filter()`.\n-   How to plot line data using `ggplot2::geom_sf()`.\n:::\n\nFor this example, we'll play with the road network shape file obtained from OpenStreetMaps. The data is in geojson format, so let's import that into R.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrd <- \n  read_sf(\"data/hotosm_brn_roads_lines_geojson/hotosm_brn_roads_lines_geojson.geojson\") |>\n  st_transform(4326)  # SET THE CRS!!! (WGS84)\nglimpse(brd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 25,570\nColumns: 15\n$ name       <chr> \"Simpang 393\", \"Simpang 405\", NA, NA, NA, NA, \"Lebuhraya Tu~\n$ `name:en`  <chr> NA, NA, NA, NA, NA, NA, \"Tutong–Telisai Highway\", NA, NA, N~\n$ highway    <chr> \"residential\", \"residential\", \"service\", \"residential\", \"tr~\n$ surface    <chr> NA, NA, NA, NA, NA, \"asphalt\", \"asphalt\", NA, NA, NA, \"asph~\n$ smoothness <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,~\n$ width      <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,~\n$ lanes      <chr> NA, NA, NA, NA, NA, \"1\", \"2\", NA, NA, NA, \"2\", NA, NA, NA, ~\n$ oneway     <chr> NA, NA, NA, NA, NA, \"yes\", \"yes\", NA, NA, NA, \"no\", \"yes\", ~\n$ bridge     <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,~\n$ layer      <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,~\n$ source     <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,~\n$ `name:ms`  <chr> NA, NA, NA, NA, NA, NA, \"Lebuhraya Tutong–Telisai\", NA, NA,~\n$ osm_id     <int> 386886618, 481030903, 512405939, 664532755, 442044892, 6651~\n$ osm_type   <chr> \"ways_line\", \"ways_line\", \"ways_line\", \"ways_line\", \"ways_l~\n$ geometry   <LINESTRING [°]> LINESTRING (114.6236 4.7910..., LINESTRING (114.~\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThere are 25,570 features in this data set, which may be a bit too much. Let's try to focus on the major roads only. This information seems to be contained in the `highway` column. What's in it?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(brd$highway)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     bridleway   construction       cycleway        footway  living_street \n             1             28             73            898             10 \n      motorway  motorway_link           path     pedestrian        primary \n           116            152            140             60            865 \n  primary_link    residential           road      secondary secondary_link \n           332           9023              1            446             79 \n       service          steps       tertiary  tertiary_link          track \n          9876             53            586             59            442 \n         trunk     trunk_link   unclassified \n           460            310           1560 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nAccording to this [wiki](https://wiki.openstreetmap.org/wiki/OpenStreetMap_Carto/Lines), In OpenStreetMap, the major roads of a road network are sorted on an importance scale, from motorway to quaternary road.\n\n![](figures/osm_roads.png)\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrd_mjr <- \n  brd |>\n  filter(highway %in% c(\"motorway\", \"trunk\", \"primary\", \"secondary\")) \nbrd_mjr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1887 features and 14 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 114.1906 ymin: 4.516642 xmax: 115.2021 ymax: 5.037115\nGeodetic CRS:  WGS 84\n# A tibble: 1,887 x 15\n   name     `name:en` highway surface smoothness width lanes oneway bridge layer\n * <chr>    <chr>     <chr>   <chr>   <chr>      <chr> <chr> <chr>  <chr>  <chr>\n 1 Lebuhra~ Tutong–T~ trunk   asphalt <NA>       <NA>  2     yes    <NA>   <NA> \n 2 Lebuhra~ Tutong–T~ trunk   asphalt <NA>       <NA>  3     yes    <NA>   <NA> \n 3 Jalan S~ <NA>      primary asphalt <NA>       <NA>  2     yes    yes    1    \n 4 Jalan S~ <NA>      primary asphalt <NA>       <NA>  2     yes    <NA>   <NA> \n 5 Lebuh R~ Seria–Be~ trunk   asphalt <NA>       <NA>  2     yes    <NA>   <NA> \n 6 <NA>     <NA>      trunk   asphalt <NA>       <NA>  2     yes    <NA>   <NA> \n 7 <NA>     <NA>      primary asphalt <NA>       <NA>  1     yes    <NA>   <NA> \n 8 Lebuh R~ Seria–Be~ trunk   asphalt <NA>       <NA>  2     yes    yes    1    \n 9 <NA>     <NA>      primary asphalt <NA>       <NA>  2     yes    <NA>   <NA> \n10 Lebuhra~ Telisai–~ trunk   asphalt <NA>       <NA>  2     yes    <NA>   <NA> \n# i 1,877 more rows\n# i 5 more variables: source <chr>, `name:ms` <chr>, osm_id <int>,\n#   osm_type <chr>, geometry <LINESTRING [°]>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd now a plot of these roads.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = brn_sf) +\n  geom_sf(data = brd_mjr, aes(col = highway), size = 0.5) +\n  # scale_colour_viridis_d(option = \"turbo\")\n  ggsci::scale_colour_npg()\n```\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-18-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\nWith this, I asked ChatGPT what kind of spatial analyses can be done on this data set. It said, when paired with appropriate data, we can do things like:\n\n1.  **Network Connectivity Analysis**\n    -   Assess reachability and identify disconnected road network components.\n2.  **Accessibility and Service Area Analysis**\n    -   Determine service areas and catchment areas for essential services.\n3.  **Traffic Simulation and Management**\n    -   Simulate traffic flow to identify bottlenecks and suggest optimal routing.\n4.  **Environmental Impact Assessment**\n    -   Estimate vehicular emissions and model noise pollution from roads.\n5.  **Urban and Regional Planning**\n    -   Examine land use compatibility and assess infrastructure development needs.\n6.  **Safety Analysis**\n    -   Identify accident hotspots and assess pedestrian safety.\n7.  **Economic Analysis**\n    -   Evaluate economic accessibility and the impact of road projects.\n\nLet's pick one of these: Calculate the distance between the centroid of several regions and the major hospital in the Belait district. This analysis guides urban and healthcare planning by pinpointing areas with inadequate access to emergency services, enabling targeted infrastructure and service improvements.\n\n### Road networks in Belait region\n\n::: {.callout-tip title=\"What we'll learn\"}\n-   Manipulating GIS data using `sf::st_intersection()` and the like. Useful for reorganising the spatial structure (without having to do this in QGIS or ArcGIS).\n-   Sampling points from a line data set.\n-   Calculating distances between points and lines using `{osrm}` package.\n:::\n\nFirst we \"crop\" the road network to the Belait region.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrd_belait <- st_intersection(\n  brd,\n  filter(dis_sf, name == \"Belait\")\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(brd_belait) +\n  geom_sf() +\n  geom_sf(data = filter(dis_sf, name == \"Belait\"), fill = NA)\n```\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-19-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\nIf we were to sample random points from the Belait polygon, we might get non-sensical areas like the extremely rural areas or forest reserves. So the idea is to sample random points from the road network itself. For this, we need a function that will get us a random point on the path itself.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_random_point <- function(linestring) {\n  coords <- st_coordinates(linestring)\n  samp_coord <- coords[sample(nrow(coords), 1), , drop = FALSE]\n  samp_coord[, 1:3]\n}\nget_random_point(brd_belait$geometry[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         X          Y         L1 \n114.241941   4.594271   1.000000 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nOnce we have this function, we need to `map()` this function onto each of the linestrings in the `brd_belait` data set. The resulting list of points is too large! So we will just sample 100 points (you can experiment with this number).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_points <-\n  map(brd_belait$geometry, get_random_point) |>\n  bind_rows() |>\n  slice_sample(n = 100)\n```\n:::\n\n\n\n\n\n\nWhat we have now is a data frame of 100 random points on the road network in the Belait district. We will use the `{osrm}` package to calculate the distance between these points and the Suri Seri Begawan Hospital in Kuala Belait. The output will be three things: 1) The duration (minutes); 2) The distance (km); and 3) a `LINESTRING` object that represents the path to get to the hospital. Unfortunately the `osrmRoute()` function is not vectorised, i.e. we have to do it one-by-one for each of the 100 points. Luckily, we can just make a `for` loop and store the results in a list.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuriseri <- c(114.198778, 4.583444)\n\nres <- list()\nfor (i in 1:100) {\n  res[[i]] <- osrmRoute(src = random_points[i, 1:2], dst = suriseri, overview = \"full\")\n}\nres <- \n  bind_rows(res) |>\n  as_tibble() |>\n  st_as_sf()\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 100 features and 4 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 114.1917 ymin: 4.32647 xmax: 114.694 ymax: 4.6949\nGeodetic CRS:  WGS 84\n# A tibble: 100 x 5\n   src   dst   duration distance                                        geometry\n   <chr> <chr>    <dbl>    <dbl>                                <LINESTRING [°]>\n 1 1     dst       8.18     6.08 (114.2209 4.57636, 114.2209 4.57636, 114.2207 ~\n 2 1     dst      16.4     11.6  (114.2952 4.60689, 114.2952 4.60689, 114.2952 ~\n 3 1     dst      43.9     49.4  (114.504 4.56998, 114.504 4.56999, 114.5038 4.~\n 4 1     dst       7.42     5.19 (114.2395 4.59226, 114.2395 4.59226, 114.2395 ~\n 5 1     dst       6.52     4.69 (114.2329 4.58381, 114.2328 4.58377, 114.2324 ~\n 6 1     dst      30.0     34.4  (114.4344 4.6501, 114.4344 4.6501, 114.4348 4.~\n 7 1     dst      33.6     39.2  (114.4911 4.67538, 114.4911 4.67491, 114.4915 ~\n 8 1     dst       4.94     3.21 (114.2224 4.58747, 114.2228 4.58751, 114.2227 ~\n 9 1     dst      14.0     10.0  (114.2817 4.60503, 114.2816 4.60503, 114.2816 ~\n10 1     dst      34.2     41.9  (114.5294 4.67255, 114.5294 4.67252, 114.5294 ~\n# i 90 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSo with all that done, we can now plot the paths taken by the 100 random points to the hospital. The map gives us an indication of which areas are underserved by the hospital, and can guide urban and healthcare planning by pinpointing areas with inadequate access to emergency services, enabling targeted infrastructure and service improvements.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(res) +\n  # geom_point(data = random_points, aes(x = X, y = Y), col = \"red\") +\n  geom_sf(data = filter(kpg_sf, district == \"Belait\"), fill = NA) +\n  geom_sf(aes(col = duration), linewidth = 1.2, alpha = 0.7) +\n  geom_point(x = suriseri[1], y = suriseri[2], col = \"red3\", pch = \"X\", \n             size = 3) +\n  scale_colour_viridis_c() \n```\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-23-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\nImproving the analysis\n\n-   Weight analysis by populous areas. Outcalls to hospitals can be modelled using a Poisson distribution with the population as the rate parameter.\n-   Use a more sophisticated routing algorithm that accounts for traffic conditions and road quality (am vs pm, weekends vs weekdays, etc.).\n-   Simpler to analyse at the kampong or mukim level?\n\n\n## Areal data (`(MULTI)POLYGONS`)\n\n::: {.callout-tip title=\"What we'll learn\"}\n-   Represent statistical data using colour mapping symbology (choropleth)\n-   Use `ggplot2::geom_label()` or `ggrepel::geom_label_repel()` to add labels to the map\n-   Using a binned colour scale, e.g. `ggplot2::geom_scale_fill_viridis_b()`\n:::\n\nWhen your study data is made up a finite number of non-overlapping areas, then you can represent them as polygons in R. This is the case for the kampong and mukim data in Brunei. As an example, let us look at the population of each kampong in Brunei. This dataset comes from the 2021 Brunei Census data [@deps2022population]\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(bn_census2021)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 365\nColumns: 11\n$ id           <dbl> 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, 16, 17, 18, 19, 2~\n$ kampong      <chr> \"Kg. Biang\", \"Kg. Amo\", \"Kg. Sibut\", \"Kg. Sumbiling Baru\"~\n$ mukim        <chr> \"Mukim Amo\", \"Mukim Amo\", \"Mukim Amo\", \"Mukim Amo\", \"Muki~\n$ district     <chr> \"Temburong\", \"Temburong\", \"Temburong\", \"Temburong\", \"Temb~\n$ population   <dbl> 75, 394, 192, 91, 108, 143, 199, 123, 95, 90, 92, 2427, 4~\n$ pop_male     <dbl> 46, 218, 98, 48, 60, 68, 115, 65, 52, 46, 73, 1219, 252, ~\n$ pop_female   <dbl> 29, 176, 94, 43, 48, 75, 84, 58, 43, 44, 19, 1208, 150, 2~\n$ pop_bruneian <dbl> 37, 280, 174, 55, 57, 64, 114, 88, 63, 35, 37, 1557, 235,~\n$ pop_pr       <dbl> 33, 83, 17, 24, 41, 64, 64, 28, 29, 32, 2, 179, 3, 67, 32~\n$ household    <dbl> 13, 83, 37, 23, 23, 23, 38, 26, 26, 23, 14, 517, 76, 691,~\n$ occ_liv_q    <dbl> 13, 62, 27, 16, 22, 21, 37, 22, 12, 23, 14, 492, 71, 681,~\n```\n\n\n:::\n:::\n\n\n\n\n\n\nEach row of the data refers to a kampong-level observation. While there are unique identifiers to this (`id`, `kampong`, `mukim`, `district`), we would still need to geocode this data set so that we can do fun things like plot it on a map. Let's use (again) `left_join()` to do this.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbn_pop_sf <- \n  left_join(\n    kpg_sf, \n    bn_census2021, \n    by = join_by(id, kampong, mukim, district)\n  )\n```\n:::\n\n\n\n\n\n\nGreat. Let's take a look at the population column. It would be very interesting to see where most of the 440,704 people of Brunei live!\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(bn_pop_sf) +\n  geom_sf(aes(fill = population)) +\n  scale_fill_viridis_c(na.value = NA)\n```\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-26-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\nAs expected, there are \"hotspots\" of population in the Brunei-Muara district, and to a lesser extent in the Belait district. We can make this graph a bit better by binning the population values. It seems to be dominated by a lot of these low value colours. Let's take a look at this further by inspecting a histogram.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(bn_pop_sf) +\n  geom_histogram(aes(population), binwidth = 100)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 75 rows containing non-finite outside the scale range\n(`stat_bin()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-27-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\nSo maybe we can bin the population into 4 categories: \\< 100, 101-1000, 1001-10000, and 10000+. For this we directly use the `scale_fill_viridis_b()` and adjust the breaks. Otherwise we would have to `cut()` the population column and then use `scale_fill_manual()`. We also added the names of the top 10 most populous kampongs to the map using `ggrepel::geom_label_repel()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkpg_labels_sf <-\n  bn_pop_sf |>\n  arrange(desc(population)) |>\n  slice_head(n = 10)\n\nbn_pop_sf |>\n  # filter(population > 50) |>\n  ggplot() +\n  geom_sf(aes(fill = population), col = NA, alpha = 0.8) +\n  geom_sf(data = kpg_sf, fill = NA, col = \"black\") +\n  ggrepel::geom_label_repel(\n    data = kpg_labels_sf,\n    aes(label = kampong, geometry = geometry),\n    stat = \"sf_coordinates\",\n    inherit.aes = FALSE,\n    box.padding = 1,\n    size = 2,\n    max.overlaps = Inf\n  ) +\n  scale_fill_viridis_b(\n    name = \"Population\",\n    na.value = NA,\n    labels = scales::comma,\n    breaks = c(0, 100, 1000, 10000, 20000)\n    # limits = c(0, 12000)\n  ) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-28-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n## OpenStreetMap data\n\n::: {.callout-tip title=\"What we'll learn\"}\n-   How to scrape OpenStreetMap data using the `{osmdata}` package.\n:::\n\nThe `{osmdata}` package is a very useful tool for scraping OpenStreetMap data. It allows you to download data from OpenStreetMap and convert it into an `sf` object. The package is built on top of the `osmdata` API, which is a wrapper around the Overpass API. The Overpass API is a read-only API that allows you to query OpenStreetMap data. Conveniently, we do not need an API key.\n\n### EXAMPLE: How to get all the schools in Brunei\n\nWhen we go to https://www.openstreetmap.org/ website, we can search for some key terms. For example, if we search for \"Sekolah Rendah Kiarong\", we see the following:\n\n![](figures/sr_kiarong.png)\n\nHighlighted in red is the polygon that represents the school. Furthermore, we have some information in the \"Tags\" section such as:\n\n- `addr:place` = Kiarong\n- `addr:street` = Jalan Datu Ratna\n- `alt_name` = Sekolah Rendah Kiarong\n- `alt_name:en` = Kiarong Primary School\n- `amenity` = school\n- etc.\n\nThe `{osmdata}` package allows us to query this information. To replicate this 'GUI' experience using code, we do the following:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nq <-\n  opq(\"brunei\") |>\n  add_osm_feature(\n    key = \"name\", \n    value = \"Sekolah Rendah Datu Ratna Haji Muhammad Jaafar\"\n  ) |>\n  osmdata_sf()\nprint(q)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nObject of class 'osmdata' with:\n                 $bbox : 4.002508,113.017925,6.546584,115.3635623\n        $overpass_call : The call submitted to the overpass API\n                 $meta : metadata including timestamp and version numbers\n           $osm_points : 'sf' Simple Features Collection with 16 points\n            $osm_lines : NULL\n         $osm_polygons : 'sf' Simple Features Collection with 1 polygons\n       $osm_multilines : NULL\n    $osm_multipolygons : NULL\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIt has found the school. To extract the information, let's look at the `$osm_polygons` entry:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(q$osm_polygons)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 1\nColumns: 10\n$ osm_id        <chr> \"309023494\"\n$ name          <chr> \"Sekolah Rendah Datu Ratna Haji Muhammad Jaafar\"\n$ `addr:place`  <chr> \"Kiarong\"\n$ `addr:street` <chr> \"Jalan Datu Ratna\"\n$ alt_name      <chr> \"Sekolah Rendah Kiarong\"\n$ `alt_name:en` <chr> \"Kiarong Primary School\"\n$ amenity       <chr> \"school\"\n$ `name:en`     <chr> \"Datu Ratna Haji Muhammad Jaafar Primary School\"\n$ source        <chr> \"Bing; survey\"\n$ geometry      <POLYGON [°]> POLYGON ((114.9125 4.892252...\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLet's plot it!\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# warning: false\nggplot(filter(kpg_sf, mukim == \"Mukim Gadong B\")) +\n  geom_sf() +\n  geom_label_repel(\n    aes(label = kampong, geometry = geometry),\n    stat = \"sf_coordinates\",\n    inherit.aes = FALSE,\n    box.padding = 1,\n    size = 3,\n    max.overlaps = Inf\n  ) +\n  geom_sf(data = q$osm_polygons, fill = \"red3\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not\ngive correct results for longitude/latitude data\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-31-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\nWe can query based on amenity type as well. For example, to get all the schools in Brunei:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bounding box for Brunei Muara\nbm_sf <- filter(kpg_sf, district == \"Brunei Muara\")\nbm_bbox <- st_bbox(bm_sf)\n\nq <-\n  opq(bm_bbox) |>\n  add_osm_feature(\n    key = \"amenity\", \n    value = \"school\"\n  ) |>\n  osmdata_sf()\nprint(q)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nObject of class 'osmdata' with:\n                 $bbox : 4.72903834429411,114.771346735899,5.04587807206061,115.138720231749\n        $overpass_call : The call submitted to the overpass API\n                 $meta : metadata including timestamp and version numbers\n           $osm_points : 'sf' Simple Features Collection with 1321 points\n            $osm_lines : NULL\n         $osm_polygons : 'sf' Simple Features Collection with 153 polygons\n       $osm_multilines : NULL\n    $osm_multipolygons : 'sf' Simple Features Collection with 1 multipolygons\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nAlmost always it is a good idea to look at the polygons, instead of the points. In any case, you can always find the centroid of the polygons if you wanted to plot point data.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschools_sf <-\n  q$osm_polygons |>\n  as_tibble() |>  # these two lines convert to tibble-like object\n  st_as_sf() |> \n  select(osm_id, name) |>\n  drop_na() |>\n  st_centroid()  # obtains X,Y coordinates of centroids\n\nprint(schools_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 138 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 114.7891 ymin: 4.730341 xmax: 115.1303 ymax: 5.036068\nGeodetic CRS:  WGS 84\n# A tibble: 138 x 3\n   osm_id    name                                                 geometry\n * <chr>     <chr>                                             <POINT [°]>\n 1 45517438  Sekolah Rendah Haji Tarif                  (114.9321 4.88012)\n 2 45768022  Sekolah Menengah Awang Semaun             (114.9389 4.876925)\n 3 45820441  Sekolah Rendah Pengiran Anak Puteri Besar (114.9397 4.874045)\n 4 45820563  Pehin Dato Jamil Primary School           (114.9473 4.873318)\n 5 157197463 Sekolah Ugama Pengiran Muda Abdul Malik ~ (114.8709 4.848966)\n 6 157489516 Sekolah Rendah Dato Marsal                (114.9576 4.961157)\n 7 167974917 Chung Hwa Middle School                   (114.9445 4.894822)\n 8 167974963 Sekolah Rendah Pusar Ulak                 (114.9358 4.896647)\n 9 167974968 St. Andrew’s School                       (114.9372 4.896313)\n10 260696860 Jerudong International School             (114.8793 4.969056)\n# i 128 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = bm_sf, aes(fill = mukim), alpha = 0.3) +\n  geom_sf(data = schools_sf, size = 2) \n```\n\n::: {.cell-output-display}\n![](2-gis_data_files/figure-pdf/unnamed-chunk-33-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\nFrom here...\n\n- Visit the [OSM Wiki](https://wiki.openstreetmap.org/wiki/Key:amenity?uselang=en-GB) to see what other amenities you can query.\n- Clearly not limited to schools -- clinics, shops, movie theatres, ...\n- Combine with the road data from `{osrm}` to calculate distances between schools and hospitals, for example.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}